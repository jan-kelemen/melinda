// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_WIRE_MEL_NETWORK_H_
#define FLATBUFFERS_GENERATED_WIRE_MEL_NETWORK_H_

#include "flatbuffers/flatbuffers.h"

namespace mel
{
    namespace network
    {
        struct message;
        struct messageBuilder;

        struct message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
        {
            typedef messageBuilder Builder;
            enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
            {
                VT_LENGTH = 4,
                VT_CONTENT = 6
            };
            int32_t length() const { return GetField<int32_t>(VT_LENGTH, 0); }
            bool mutate_length(int32_t _length)
            {
                return SetField<int32_t>(VT_LENGTH, _length, 0);
            }
            const flatbuffers::String* content() const
            {
                return GetPointer<const flatbuffers::String*>(VT_CONTENT);
            }
            flatbuffers::String* mutable_content()
            {
                return GetPointer<flatbuffers::String*>(VT_CONTENT);
            }
            bool Verify(flatbuffers::Verifier& verifier) const
            {
                return VerifyTableStart(verifier) &&
                    VerifyField<int32_t>(verifier, VT_LENGTH) &&
                    VerifyOffset(verifier, VT_CONTENT) &&
                    verifier.VerifyString(content()) && verifier.EndTable();
            }
        };

        struct messageBuilder
        {
            typedef message Table;
            flatbuffers::FlatBufferBuilder& fbb_;
            flatbuffers::uoffset_t start_;
            void add_length(int32_t length)
            {
                fbb_.AddElement<int32_t>(message::VT_LENGTH, length, 0);
            }
            void add_content(flatbuffers::Offset<flatbuffers::String> content)
            {
                fbb_.AddOffset(message::VT_CONTENT, content);
            }
            explicit messageBuilder(flatbuffers::FlatBufferBuilder& _fbb)
                : fbb_(_fbb)
            {
                start_ = fbb_.StartTable();
            }
            messageBuilder& operator=(const messageBuilder&);
            flatbuffers::Offset<message> Finish()
            {
                const auto end = fbb_.EndTable(start_);
                auto o = flatbuffers::Offset<message>(end);
                return o;
            }
        };

        inline flatbuffers::Offset<message> Createmessage(
            flatbuffers::FlatBufferBuilder& _fbb,
            int32_t length = 0,
            flatbuffers::Offset<flatbuffers::String> content = 0)
        {
            messageBuilder builder_(_fbb);
            builder_.add_content(content);
            builder_.add_length(length);
            return builder_.Finish();
        }

        inline flatbuffers::Offset<message> CreatemessageDirect(
            flatbuffers::FlatBufferBuilder& _fbb,
            int32_t length = 0,
            const char* content = nullptr)
        {
            auto content__ = content ? _fbb.CreateString(content) : 0;
            return mel::network::Createmessage(_fbb, length, content__);
        }

    } // namespace network
} // namespace mel

#endif // FLATBUFFERS_GENERATED_WIRE_MEL_NETWORK_H_
